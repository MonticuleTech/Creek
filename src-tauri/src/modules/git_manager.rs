// Git Manager Module
//
// DESIGN: Document snapshots and rollback based on git
//
// Implementation Notes:
//   - Automatically generate commit message after each modification (generated by LLM)
//   - Support emergency rollback to any historical version
//   - git log serves as part of long-range context

use anyhow::{Result, Context};
use git2::{Repository, Signature, IndexAddOption, Oid};
use std::path::Path;
use std::fs;
use crate::services::llm_client::{LLMClient, ChatMessage};
use crate::prompts::state_manager::generate_commit_message_prompt;
use crate::utils::text::clean_concise_output;
use futures_util::StreamExt;
use log::info;

const DOCUMENT_FILENAME: &str = "document.md";

fn document_filename(recording_path: &Path) -> String {
    recording_path
        .file_name()
        .and_then(|name| name.to_str())
        .map(|name| format!("{}.md", name))
        .unwrap_or_else(|| DOCUMENT_FILENAME.to_string())
}

/// GitManager handles git operations for document version control
pub struct GitManager;

impl GitManager {
    /// Create a new GitManager
    pub fn new() -> Self {
        Self
    }
    
    /// Initialize git repository for a recording if not exists
    pub fn init_repo<P: AsRef<Path>>(&self, recording_path: P) -> Result<Repository> {
        let recording_path = recording_path.as_ref();
        let git_path = recording_path.join(".git");
        
        if git_path.exists() {
            // Repo already exists, open it
            info!("[Git Manager] Opening existing repository");
            Repository::open(recording_path)
                .context("Failed to open existing git repository")
        } else {
            // Create new repo
            fs::create_dir_all(recording_path)
                .context("Failed to create recording directory")?;
            
            info!("[Git Manager] Initializing new repository");
            let repo = Repository::init(recording_path)
                .context("Failed to initialize git repository")?;
            
            // Create initial commit with empty document
            let doc_path = recording_path.join(document_filename(recording_path));
            fs::write(&doc_path, "")
                .context("Failed to create initial document")?;
            
            self.commit_internal(&repo, "Initial commit")?;
            info!("[Git Manager] Initial commit created");
            
            Ok(repo)
        }
    }
    
    /// Generate commit message using LLM
    pub async fn generate_commit_message<T: LLMClient>(
        &self,
        llm: &T,
        diff: &str,
    ) -> Result<String> {
        // Skip if diff is empty
        if diff.trim().is_empty() {
            return Ok("Document updated".to_string());
        }
        
        info!("[Git Manager] Generating commit message...");
        
        let prompt = generate_commit_message_prompt(diff);
        let messages = vec![
            ChatMessage {
                role: "user".to_string(),
                content: prompt,
            }
        ];
        
        // Call LLM with timeout and fallback
        let commit_msg = match tokio::time::timeout(
            std::time::Duration::from_secs(10),
            self.collect_llm_response(llm, messages)
        ).await {
            Ok(Ok(response)) => {
                let cleaned = clean_concise_output(&response);
                // Validate: must be reasonable length
                if cleaned.is_empty() || cleaned.len() > 150 {
                    "Document updated".to_string()
                } else {
                    cleaned
                }
            }
            _ => "Document updated".to_string(), // Fallback
        };
        
        info!("[Git Manager] Commit message generated: {}", commit_msg);
        
        Ok(commit_msg)
    }
    
    /// Helper to collect full LLM response from stream
    async fn collect_llm_response<T: LLMClient>(
        &self,
        llm: &T,
        messages: Vec<ChatMessage>,
    ) -> Result<String> {
        let mut stream = llm.stream_completion(messages).await
            .map_err(|e| anyhow::anyhow!("LLM error: {:?}", e))?;
        
        let mut response = String::new();
        while let Some(chunk_result) = stream.next().await {
            match chunk_result {
                Ok(chunk) => response.push_str(&chunk),
                Err(e) => return Err(anyhow::anyhow!("Stream error: {:?}", e)),
            }
        }
        
        Ok(response)
    }
    
    /// Write document content and create commit
    pub fn commit<P: AsRef<Path>>(
        &self,
        recording_path: P,
        content: &str,
        message: &str,
    ) -> Result<Oid> {
        let recording_path = recording_path.as_ref();
        
        // Write document file
        let doc_path = recording_path.join(document_filename(recording_path));
        fs::write(&doc_path, content)
            .context("Failed to write document file")?;
        
        // Open or init repo
        let repo = if recording_path.join(".git").exists() {
            Repository::open(recording_path)?
        } else {
            self.init_repo(recording_path)?
        };
        
        // Commit
        self.commit_internal(&repo, message)
    }
    
    /// Commit already-written changes (file must be written before calling this)
    pub fn commit_existing<P: AsRef<Path>>(
        &self,
        recording_path: P,
        message: &str,
    ) -> Result<Oid> {
        let recording_path = recording_path.as_ref();
        
        // Open or init repo
        let repo = if recording_path.join(".git").exists() {
            Repository::open(recording_path)?
        } else {
            self.init_repo(recording_path)?
        };
        
        // Commit
        self.commit_internal(&repo, message)
    }
    
    /// Internal commit helper
    fn commit_internal(&self, repo: &Repository, message: &str) -> Result<Oid> {
        let mut index = repo.index()?;
        
        // Add all files
        index.add_all(["*"].iter(), IndexAddOption::DEFAULT, None)?;
        index.write()?;
        
        let tree_id = index.write_tree()?;
        let tree = repo.find_tree(tree_id)?;
        
        // Get parent commit if exists
        let parent_commit = repo.head()
            .ok()
            .and_then(|head| head.peel_to_commit().ok());
        
        // Create signature
        let sig = Signature::now("Creek", "creek@local")?;
        
        // Create commit
        let oid = if let Some(parent) = parent_commit {
            repo.commit(
                Some("HEAD"),
                &sig,
                &sig,
                message,
                &tree,
                &[&parent],
            )?
        } else {
            repo.commit(
                Some("HEAD"),
                &sig,
                &sig,
                message,
                &tree,
                &[],
            )?
        };
        
        Ok(oid)
    }
    
    /// Get commit history (last N commits)
    pub fn get_history<P: AsRef<Path>>(&self, recording_path: P, limit: usize) -> Result<Vec<String>> {
        let items = self.get_history_with_hashes(recording_path, limit)?;
        Ok(items.into_iter().map(|(_, msg)| msg).collect())
    }

    /// Get commit history with hashes (last N commits)
    pub fn get_history_with_hashes<P: AsRef<Path>>(&self, recording_path: P, limit: usize) -> Result<Vec<(String, String)>> {
        let repo = Repository::open(recording_path.as_ref())
            .context("Failed to open repository")?;
        
        let mut revwalk = repo.revwalk()?;
        revwalk.push_head()?;
        
        let mut history = Vec::new();
        for (i, oid) in revwalk.enumerate() {
            if i >= limit {
                break;
            }
            
            let oid = oid?;
            let commit = repo.find_commit(oid)?;
            if let Some(msg) = commit.message() {
                history.push((oid.to_string(), msg.to_string()));
            }
        }
        
        Ok(history)
    }
    
    /// Get current diff (unstaged + staged changes)
    pub fn get_diff<P: AsRef<Path>>(&self, recording_path: P) -> Result<String> {
        let repo = Repository::open(recording_path.as_ref())
            .context("Failed to open repository")?;
        
        // Get HEAD tree
        let head = repo.head()?;
        let head_commit = head.peel_to_commit()?;
        let head_tree = head_commit.tree()?;
        
        // Get working directory tree (current state)
        let mut index = repo.index()?;
        index.add_all(["*"].iter(), IndexAddOption::DEFAULT, None)?;
        let index_tree_id = index.write_tree()?;
        let index_tree = repo.find_tree(index_tree_id)?;
        
        // Compute diff
        let diff = repo.diff_tree_to_tree(Some(&head_tree), Some(&index_tree), None)?;
        
        // Format diff as string
        let mut diff_text = String::new();
        diff.print(git2::DiffFormat::Patch, |_delta, _hunk, line| {
            let content = String::from_utf8_lossy(line.content());
            diff_text.push_str(&content);
            true
        })?;
        
        let diff_lines = diff_text.lines().count();
        info!("[Git Manager] Diff generated: {} lines", diff_lines);
        
        Ok(diff_text)
    }
    
    /// Rollback to a specific commit
    pub fn rollback<P: AsRef<Path>>(&self, recording_path: P, commit_hash: &str) -> Result<String> {
        let repo = Repository::open(recording_path.as_ref())
            .context("Failed to open repository")?;
        
        // Parse commit hash (supports short hash, HEAD~1, etc.)
        let obj = repo.revparse_single(commit_hash)
            .context("Invalid commit hash or ref")?;
        
        let commit = obj.peel_to_commit()
            .context("Target object is not a commit")?;
        
        let tree = commit.tree()?;
        
        // Checkout the tree
        repo.checkout_tree(tree.as_object(), None)?;
        
        // Update HEAD
        repo.set_head_detached(commit.id())?;
        
        // Read document content
        let doc_path = recording_path.as_ref().join(document_filename(recording_path.as_ref()));
        let content = fs::read_to_string(&doc_path)
            .context("Failed to read document after rollback")?;
        
        Ok(content)
    }
}

impl Default for GitManager {
    fn default() -> Self {
        Self::new()
    }
}
