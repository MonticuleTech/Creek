// State Manager Module
//
// DESIGN: Maintain multi-level state to support long-range editing and dynamic context assembly
//
// Maintained State:
//   struct State {
//       current_doc: String,                     // Current full text
//       focus: String,                           // Current focus point (brief description)
//       git_history: Vec<String>,                // Recent 10 commit messages
//       todo_list: Vec<TodoItem>,                // Incomplete task list
//       rag_context: Vec<ConversationTurn>,      // RAG search results (dynamically populated)
//   }
//
// Implementation Notes:
//   - Automatically generate focus description after each modification (generated by LLM)
//   - Todo list can be co-created with user (model generation + user correction)
//   - rag_context field only populated by RAG Module when Router 2 determines "need retrieval"
//   - All state persisted to SQLite
//
// Context Assembly Logic:
//   fn build_context(state: &State, need_rag: bool) -> String {
//       // Basic context: Router 2 uses this part to determine if information is missing
//       let mut ctx = format!("Current document:\n{}\n", state.current_doc);
//       ctx += &format!("Current focus: {}\n", state.focus);
//       
//       if !state.git_history.is_empty() {
//           ctx += "Recent modifications:\n";
//           for msg in &state.git_history {
//               ctx += &format!("- {}\n", msg);
//           }
//       }
//       
//       if !state.todo_list.is_empty() {
//           ctx += "Incomplete tasks:\n";
//           for todo in &state.todo_list {
//               ctx += &format!("- {}\n", todo.desc);
//           }
//       }
//       
//       // RAG context: Only supplemented when Router 2 determines needed
//       if need_rag && !state.rag_context.is_empty() {
//           ctx += "\nRelevant historical conversations:\n";
//           for turn in &state.rag_context {
//               ctx += &format!("- [{}] User: {}\n", turn.timestamp, turn.asr_input);
//               if let Some(mod) = &turn.modification {
//                   ctx += &format!("  Modification: {}\n", mod);
//               }
//           }
//       }
//       
//       ctx
//   }

use serde::{Deserialize, Serialize};
use rusqlite::Connection;
use std::sync::{Arc, Mutex};
use anyhow::{Result, Context};
use crate::services::llm_client::{LLMClient, ChatMessage};
use crate::prompts::state_manager::generate_focus_prompt;
use crate::utils::text::clean_concise_output;
use futures_util::StreamExt;
use log::info;

const MAX_GIT_HISTORY: usize = 10;

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct TodoItem {
    pub id: String,
    pub desc: String,
    pub completed: bool,
    #[serde(default)]
    pub completed_turns_ago: Option<usize>, // Track how many turns ago it was completed
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct DocumentState {
    pub current_doc: String,
    pub focus: String,
    pub git_history: Vec<String>,
    pub todo_list: Vec<TodoItem>,
    // pub rag_context: Vec<ConversationTurn>,  // Uncomment when implementing RAG
}

impl Default for DocumentState {
    fn default() -> Self {
        Self {
            current_doc: String::new(),
            focus: String::new(),
            git_history: Vec::new(),
            todo_list: Vec::new(),
        }
    }
}

/// StateManager manages document state persistence and context assembly
pub struct StateManager {
    db: Arc<Mutex<Connection>>,
    current_recording_id: Arc<Mutex<Option<String>>>,
    current_state: Arc<Mutex<DocumentState>>,
}

impl StateManager {
    /// Create a new StateManager with SQLite database
    pub fn new(db_path: &str) -> Result<Self> {
        let conn = Connection::open(db_path)
            .context("Failed to open SQLite database")?;
        
        let manager = Self {
            db: Arc::new(Mutex::new(conn)),
            current_recording_id: Arc::new(Mutex::new(None)),
            current_state: Arc::new(Mutex::new(DocumentState::default())),
        };
        
        manager.init_db()?;
        Ok(manager)
    }
    
    /// Initialize database tables
    fn init_db(&self) -> Result<()> {
        let db = self.db.lock().unwrap();
        
        db.execute(
            "CREATE TABLE IF NOT EXISTS document_states (
                recording_id TEXT PRIMARY KEY,
                current_doc TEXT NOT NULL,
                focus TEXT NOT NULL,
                git_history TEXT NOT NULL,
                todo_list TEXT NOT NULL,
                updated_at INTEGER NOT NULL
            )",
            [],
        )?;
        
        db.execute(
            "CREATE TABLE IF NOT EXISTS active_recording (
                id INTEGER PRIMARY KEY CHECK (id = 1),
                recording_id TEXT
            )",
            [],
        )?;
        
        Ok(())
    }
    
    /// Set the current active recording ID
    pub fn set_current_recording(&self, recording_id: String) -> Result<()> {
        let mut current = self.current_recording_id.lock().unwrap();
        *current = Some(recording_id.clone());
        
        // Try to load existing state
        if let Ok(state) = self.load_state(&recording_id) {
            let mut current_state = self.current_state.lock().unwrap();
            *current_state = state;
        } else {
            // Initialize new state
            let mut current_state = self.current_state.lock().unwrap();
            *current_state = DocumentState::default();
        }
        
        // Update active_recording table
        let db = self.db.lock().unwrap();
        db.execute(
            "INSERT OR REPLACE INTO active_recording (id, recording_id) VALUES (1, ?1)",
            [&recording_id],
        )?;
        
        Ok(())
    }
    
    /// Clear the current recording (on stop)
    pub fn clear_current_recording(&self) -> Result<()> {
        let mut current = self.current_recording_id.lock().unwrap();
        *current = None;
        
        let db = self.db.lock().unwrap();
        db.execute("DELETE FROM active_recording WHERE id = 1", [])?;
        
        Ok(())
    }

    /// Completely reset/delete state for a specific recording (Hard Reset)
    pub fn reset_recording_state(&self, recording_id: &str) -> Result<()> {
        // 1. Delete from DB
        let db = self.db.lock().unwrap();
        db.execute("DELETE FROM document_states WHERE recording_id = ?1", [recording_id])?;
        
        // 2. If it is the current recording, reset in-memory state
        let current_id_lock = self.current_recording_id.lock().unwrap();
        if let Some(current) = current_id_lock.as_ref() {
            if current == recording_id {
                let mut current_state = self.current_state.lock().unwrap();
                *current_state = DocumentState::default();
            }
        }
        
        info!("[State Manager] Deleted Recording State: {}", recording_id);
        Ok(())
    }
    
    /// Update the current document content
    pub fn update_document(&self, content: String) {
        let content_len = content.len();
        let mut state = self.current_state.lock().unwrap();
        state.current_doc = content;
        
        // Increment turn counter for completed todos
        for todo in &mut state.todo_list {
            if todo.completed {
                if let Some(turns) = todo.completed_turns_ago {
                    todo.completed_turns_ago = Some(turns + 1);
                } else {
                    // Just completed, this shouldn't happen but handle gracefully
                    todo.completed_turns_ago = Some(1);
                }
            }
        }
        
        // Log state update
        info!("[State Manager] Document Updated");
        info!("  Document length: {} chars", content_len);
        info!("  Current focus: {}", if state.focus.is_empty() { "(empty)" } else { &state.focus });
        info!("  Git history entries: {}", state.git_history.len());
        info!("  Active todos: {}", state.todo_list.iter().filter(|t| !t.completed).count());
        let completed_count = state.todo_list.iter().filter(|t| t.completed).count();
        if completed_count > 0 {
            info!("  Completed todos (retained): {}", completed_count);
        }
    }
    
    /// Generate focus description using LLM and update state
    pub async fn generate_and_update_focus<T: LLMClient>(&self, llm: &T, content: &str) -> Result<String> {
        // Skip if content is empty
        if content.trim().is_empty() {
            return Ok("Empty document".to_string());
        }
        
        let prompt = generate_focus_prompt(content);
        let messages = vec![
            ChatMessage {
                role: "user".to_string(),
                content: prompt,
            }
        ];
        
        // Call LLM with timeout and fallback
        let focus = match tokio::time::timeout(
            std::time::Duration::from_secs(10),
            self.collect_llm_response(llm, messages)
        ).await {
            Ok(Ok(response)) => {
                let cleaned = clean_concise_output(&response);
                if cleaned.is_empty() || cleaned.len() > 150 {
                    "Document updated".to_string()
                } else {
                    cleaned
                }
            }
            _ => "Document updated".to_string(), // Fallback
        };
        
        // Update state
        let mut state = self.current_state.lock().unwrap();
        state.focus = focus.clone();
        
        info!("[State Manager] Focus Updated: {}", focus);
        
        Ok(focus)
    }
    
    /// Helper to collect full LLM response from stream
    async fn collect_llm_response<T: LLMClient>(&self, llm: &T, messages: Vec<ChatMessage>) -> Result<String> {
        let mut stream = llm.stream_completion(messages).await
            .map_err(|e| anyhow::anyhow!("LLM error: {:?}", e))?;
        
        let mut response = String::new();
        while let Some(chunk_result) = stream.next().await {
            match chunk_result {
                Ok(chunk) => response.push_str(&chunk),
                Err(e) => return Err(anyhow::anyhow!("Stream error: {:?}", e)),
            }
        }
        
        Ok(response)
    }
    
    /// Add a commit message to git history (keep last 10)
    pub fn add_git_history(&self, commit_msg: String) {
        let mut state = self.current_state.lock().unwrap();
        state.git_history.push(commit_msg.clone());
        
        // Keep only last MAX_GIT_HISTORY entries
        let len = state.git_history.len();
        if len > MAX_GIT_HISTORY {
            state.git_history.drain(0..len - MAX_GIT_HISTORY);
        }
        
        info!("[State Manager] Git History Added: {} (total: {})", commit_msg, state.git_history.len());
    }
    
    /// Refresh git history from repository (useful after manual commits)
    pub fn refresh_git_history<P: AsRef<std::path::Path>>(&self, recording_path: P, git_manager: &crate::modules::GitManager) -> Result<()> {
        let history = git_manager.get_history(recording_path, MAX_GIT_HISTORY)?;
        let mut state = self.current_state.lock().unwrap();
        state.git_history = history;
        info!("[State Manager] Refreshed git history ({} entries)", state.git_history.len());
        Ok(())
    }
    
    /// Add a todo item
    pub fn add_todo(&self, id: String, desc: String) {
        let mut state = self.current_state.lock().unwrap();
        state.todo_list.push(TodoItem {
            id: id.clone(),
            desc: desc.clone(),
            completed: false,
            completed_turns_ago: None,
        });
        info!("[State Manager] Todo Added: {} (id: {})", desc, id);
    }
    
    /// Update a todo item's description
    pub fn update_todo(&self, id: &str, new_desc: String) -> Result<()> {
        let mut state = self.current_state.lock().unwrap();
        if let Some(todo) = state.todo_list.iter_mut().find(|t| t.id == id) {
            todo.desc = new_desc;
            Ok(())
        } else {
            Err(anyhow::anyhow!("Todo not found: {}", id))
        }
    }
    
    /// Toggle todo completion status
    pub fn toggle_todo(&self, id: &str) -> Result<bool> {
        let mut state = self.current_state.lock().unwrap();
        if let Some(todo) = state.todo_list.iter_mut().find(|t| t.id == id) {
            todo.completed = !todo.completed;
            if todo.completed {
                todo.completed_turns_ago = Some(0); // Start counting turns
            } else {
                todo.completed_turns_ago = None; // Reset if uncompleted
            }
            Ok(todo.completed)
        } else {
            Err(anyhow::anyhow!("Todo not found: {}", id))
        }
    }
    
    /// Complete a todo (marks as completed, will be retained for 5 turns)
    pub fn complete_todo(&self, id: &str) -> Result<()> {
        let mut state = self.current_state.lock().unwrap();
        if let Some(todo) = state.todo_list.iter_mut().find(|t| t.id == id) {
            todo.completed = true;
            todo.completed_turns_ago = Some(0); // Start counting turns
            info!("[State Manager] Todo Completed: {} (will be removed after 5 turns)", todo.desc);
            Ok(())
        } else {
            Err(anyhow::anyhow!("Todo not found: {}", id))
        }
    }
    
    /// Delete a todo item
    pub fn delete_todo(&self, id: &str) -> Result<()> {
        let mut state = self.current_state.lock().unwrap();
        let initial_len = state.todo_list.len();
        state.todo_list.retain(|t| t.id != id);
        if state.todo_list.len() < initial_len {
            Ok(())
        } else {
            Err(anyhow::anyhow!("Todo not found: {}", id))
        }
    }
    
    /// Remove completed todos that have been retained for 5+ turns
    pub fn remove_completed_todos(&self) {
        let mut state = self.current_state.lock().unwrap();
        let initial_len = state.todo_list.len();
        
        // Only remove if completed_turns_ago >= 5
        state.todo_list.retain(|t| {
            if t.completed {
                if let Some(turns) = t.completed_turns_ago {
                    if turns >= 5 {
                        info!("[State Manager] Removing: {} (completed {} turns ago)", t.desc, turns);
                        return false; // Remove this todo
                    }
                }
            }
            true // Keep this todo
        });
        
        let removed_count = initial_len - state.todo_list.len();
        if removed_count > 0 {
            info!("[State Manager] Removed {} old completed todos", removed_count);
        }
    }
    
    /// Get all todos
    pub fn get_todos(&self) -> Vec<TodoItem> {
        let state = self.current_state.lock().unwrap();
        state.todo_list.clone()
    }
    
    /// Get current state
    pub fn get_state(&self) -> DocumentState {
        let state = self.current_state.lock().unwrap();
        state.clone()
    }
    
    /// Build context string for LLM (as specified in DESIGN.md)
    pub fn build_context(&self, need_rag: bool) -> String {
        let state = self.current_state.lock().unwrap();
        
        let mut ctx = format!("Current document:\n{}\n", state.current_doc);
        ctx += &format!("Current focus: {}\n", state.focus);
        
        if !state.git_history.is_empty() {
            ctx += "Recent modifications:\n";
            for msg in &state.git_history {
                ctx += &format!("- {}\n", msg);
            }
        }
        
        if !state.todo_list.is_empty() {
            ctx += "Incomplete tasks:\n";
            for todo in &state.todo_list {
                ctx += &format!("- {}\n", todo.desc);
            }
        }
        
        // RAG context would be added here when needed
        if need_rag {
            // TODO: Add rag_context when RAG module is implemented
            ctx += "\n[RAG context not yet implemented]\n";
        }
        
        ctx
    }
    
    /// Persist current state to SQLite
    pub fn persist_state(&self) -> Result<()> {
        let recording_id = self.current_recording_id.lock().unwrap();
        let recording_id = match recording_id.as_ref() {
            Some(id) => id,
            None => return Ok(()), // No active recording, skip persistence
        };
        
        let state = self.current_state.lock().unwrap();
        
        let git_history_json = serde_json::to_string(&state.git_history)?;
        let todo_list_json = serde_json::to_string(&state.todo_list)?;
        let timestamp = std::time::SystemTime::now()
            .duration_since(std::time::UNIX_EPOCH)?
            .as_secs() as i64;
        
        let db = self.db.lock().unwrap();
        db.execute(
            "INSERT OR REPLACE INTO document_states 
             (recording_id, current_doc, focus, git_history, todo_list, updated_at) 
             VALUES (?1, ?2, ?3, ?4, ?5, ?6)",
            rusqlite::params![
                recording_id,
                &state.current_doc,
                &state.focus,
                &git_history_json,
                &todo_list_json,
                timestamp,
            ],
        )?;
        
        info!("[State Manager] State Persisted to DB for Recording: {}", recording_id);
        
        Ok(())
    }
    
    /// Load state from SQLite
    pub fn load_state(&self, recording_id: &str) -> Result<DocumentState> {
        let db = self.db.lock().unwrap();
        
        let mut stmt = db.prepare(
            "SELECT current_doc, focus, git_history, todo_list 
             FROM document_states 
             WHERE recording_id = ?1"
        )?;
        
        let state = stmt.query_row([recording_id], |row| {
            let current_doc: String = row.get(0)?;
            let focus: String = row.get(1)?;
            let git_history_json: String = row.get(2)?;
            let todo_list_json: String = row.get(3)?;
            
            let git_history: Vec<String> = serde_json::from_str(&git_history_json)
                .unwrap_or_default();
            let todo_list: Vec<TodoItem> = serde_json::from_str(&todo_list_json)
                .unwrap_or_default();
            
            Ok(DocumentState {
                current_doc,
                focus,
                git_history,
                todo_list,
            })
        })?;
        
        Ok(state)
    }
}
